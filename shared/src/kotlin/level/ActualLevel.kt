package level

import level.generator.LevelType
import level.update.LevelObjectAdd
import level.update.LevelUpdate
import main.Game
import network.ServerNetworkManager
import network.User
import network.packet.*
import player.PlayerManager
import player.lobby.Lobby
import serialization.Id
import serialization.Serialization
import java.util.*

/**
 * As opposed to the [RemoteLevel], an [ActualLevel] is an authoritative instance of the state of the level with the
 * given [id] and [info]. [LevelUpdate]s in this level will be sent over the network to clients in the [currentLobby].
 */
class ActualLevel(id: UUID, info: LevelInfo) : Level(id, info), PacketHandler {

    private constructor() : this(UUID.randomUUID(), LevelInfo(User(UUID.randomUUID(), ""), "", "", LevelType.EMPTY, 0))

    /**
     * The current [Lobby] this level is loaded in. Used for determining who to send [LevelUpdate]s to.
     */
    @Id(13)
    var currentLobby: Lobby? = null

    override fun initialize() {
        if (Game.IS_SERVER) {
            ServerNetworkManager.registerClientPacketHandler(
                this,
                PacketType.REQUEST_LEVEL_DATA,
                PacketType.REQUEST_CHUNK_DATA,
                PacketType.LEVEL_LOADED_SUCCESS
            )
            super.initialize()
        }
    }

    override fun load() {
        val loadedData = LevelManager.tryLoadLevelDataFile(id)
        if (loadedData != null) {
            data = loadedData
            for (chunk in data.chunks) {
                // regenerate tiles because they don't get sent to save space
                chunk.data.tiles = generator.generateTiles(chunk.xChunk, chunk.yChunk)
            }
        } else {
            data = generator.generateData()
        }
        super.load()
    }

    override fun modify(update: LevelUpdate, transient: Boolean): Boolean {
        if (!transient) {
            val copy = Serialization.copy(update)
            val success = canModify(update)
            if (success) {
                val playersToSendTo = update.playersToSendTo
                println("sending level update $copy")
                // send the packet first, then the update, so that updates that are generated by this update don't
                // get sent before the update that caused them
                currentLobby?.sendPacket(
                    LevelUpdatePacket(copy),
                    playersToSendTo ?: currentLobby!!.players
                )
                super.modify(update, false)
                return true
            } else {
                return false
            }
        } else {
            return super.modify(update, true)
        }
    }

    override fun handleClientPacket(packet: Packet) {
        if (packet is RequestLevelDataPacket) {
            if (packet.levelId == id) {
                ServerNetworkManager.sendToClient(LevelDataPacket(id, data, updatesCount), packet.connectionId)
            }
        } else if (packet is LevelLoadedSuccessPacket) {
            if (packet.levelId == id) {
                // connect player to lobby
                val player = PlayerManager.getPlayer(packet.fromUser)
                player.lobby.connectPlayer(player)
                if (currentLobby == null) {
                    currentLobby = player.lobby
                } else {
                    currentLobby = player.lobby.merge(currentLobby!!)
                }
            }
        }
    }

    override fun handleServerPacket(packet: Packet) {
    }
}